/*! For license information please see 9829.js.LICENSE.txt */
"use strict";(self.webpackChunkmp_webgl=self.webpackChunkmp_webgl||[]).push([[9829],{43543:(e,t,s)=>{s.d(t,{v:()=>S,X:()=>A});var o=s(68909),r=s(7478),i=s(9139),n=s(56637),a=s(52947);class c{constructor(){this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[],[]],this.boundingBox=null,this.boundingSphere=null}}class h{constructor(e,t,s,r,i,n=0){this.a=e,this.b=t,this.c=s,this.materialIndex=n,this.a=e,this.b=t,this.c=s,this.normal=r&&!Array.isArray(r)&&r.isVector3?r:new o.Vector3,this.vertexNormals=Array.isArray(r)?r:[],this.color=i&&!Array.isArray(i)&&i.isColor?i:new o.Color,this.vertexColors=Array.isArray(i)?i:[],this.materialIndex=n}clone(){return new h(this.a,this.b,this.c,this.normal,this.color).copy(this)}copy(e){this.a=e.a,this.b=e.b,this.c=e.c,this.normal.copy(e.normal),this.color.copy(e.color),this.materialIndex=e.materialIndex;for(let t=0,s=e.vertexNormals.length;t<s;t++)this.vertexNormals[t]=e.vertexNormals[t].clone();for(let t=0,s=e.vertexColors.length;t<s;t++)this.vertexColors[t]=e.vertexColors[t].clone();return this}}var l=s(53172);const u=new i.Vy("surface-edge-finder"),m=new o.Triangle,f=["a","b","c"];class d extends h{constructor(e,t,s,r){super(e.a,e.b,e.c,e.normal),this.va=t,this.vb=s,this.vc=r,this.area=m.set(this.va.vector,this.vb.vector,this.vc.vector).getArea(),this.midpoint=m.getMidpoint(new o.Vector3),this.vertices=[this.va,this.vb,this.vc],t.faces.push(this),s.faces.push(this),r.faces.push(this)}}class p{constructor(e){this.vector=e,this.faces=[]}}class g{constructor(){this.area=0,this.normal=new o.Vector3,this.midpoint=new o.Vector3,this.faces=[],this.normalSum=new o.Vector3,this.midpointSum=new o.Vector3}add(e){e.surface&&e.surface.remove(e),this.faces.push(e),this.area+=e.area,this.midpointSum.add(e.midpoint),this.normalSum.add(e.normal),this.recalcFromSums(),e.surface=this}remove(e){e.surface&&(this.faces.splice(this.faces.indexOf(e),1),this.area-=e.area,this.midpointSum.sub(e.midpoint),this.normalSum.sub(e.normal),this.recalcFromSums()),e.surface=null}recalcFromSums(){this.normal.copy(this.normalSum).normalize(),this.midpoint.copy(this.midpointSum).divideScalar(this.faces.length)}mergeSurfaces(e){for(const t of e.faces)t.surface=this,this.faces.push(t);this.area+=e.area,this.normalSum.add(e.normalSum),this.midpointSum.add(e.midpointSum),this.recalcFromSums(),e.faces=[],e.area=0,e.normal.set(0,0,0),e.normalSum.set(0,0,0),e.midpointSum.set(0,0,0),e.midpoint.set(0,0,0)}getEdges(){const e={},t={};for(const t of this.faces)for(let s=0;s<3;s++){const o=t[f[s]],r=t[f[(s+1)%3]],i=Math.min(o,r)+","+Math.max(o,r);if(void 0===e[i]){const t={edge1:o,edge2:r,isEdge:!0};e[i]=t}else e[i].isEdge=!1}for(const{edge1:s,edge2:o,isEdge:r}of Object.values(e))r&&(t[s]||(t[s]=[]),t[s].push(o),t[o]||(t[o]=[]),t[o].push(s));return t}getCircularPaths(e){const t=this.getEdges(),s=new Set,o=[],r=Object.keys(t).map((e=>parseInt(e,10)));let i;for(;i=r.pop();){const r=[];for(;i;){let o;r.push(e[i]);let n=0;for(const r of t[i]){const t=Math.min(i,r)+","+Math.max(i,r);if(s.has(t))continue;const a=e[i].vector.distanceToSquared(this.midpoint);(void 0===o||a>n)&&(o=r,n=a)}if(!o)break;{const e=Math.min(i,o)+","+Math.max(i,o);s.add(e),i=o}}r.length>2&&o.push(r)}return o}}class v{constructor(){this.surfaces=new Set,this.lines=[],this.points=[]}*run(e,t=[1,5,10],s=.2,r=.01,i=20){const n=function(e){const t=new c,s=null!==e.index?e.index:void 0,r=e.attributes;if(void 0===r.position)throw Error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.");const i=r.position,n=r.normal,a=r.color,l=r.uv,u=r.uv2;void 0!==u&&(t.faceVertexUvs[1]=[]);for(let e=0;e<i.count;e++)t.vertices.push((new o.Vector3).fromBufferAttribute(i,e)),void 0!==a&&t.colors.push((new o.Color).fromBufferAttribute(a,e));function m(e,s,r,i=0){const c=void 0===a?[]:[t.colors[e].clone(),t.colors[s].clone(),t.colors[r].clone()],m=void 0===n?[]:[(new o.Vector3).fromBufferAttribute(n,e),(new o.Vector3).fromBufferAttribute(n,s),(new o.Vector3).fromBufferAttribute(n,r)],f=new h(e,s,r,m,c,i);t.faces.push(f),void 0!==l&&t.faceVertexUvs[0].push((new o.Vector2).fromBufferAttribute(l,e),(new o.Vector2).fromBufferAttribute(l,s),(new o.Vector2).fromBufferAttribute(l,r)),void 0!==u&&t.faceVertexUvs[1].push((new o.Vector2).fromBufferAttribute(u,e),(new o.Vector2).fromBufferAttribute(u,s),(new o.Vector2).fromBufferAttribute(u,r))}const f=e.groups;if(f.length>0)for(let e=0;e<f.length;e++){const t=f[e],o=t.start;for(let e=o,r=o+t.count;e<r;e+=3)void 0!==s?m(s.getX(e),s.getX(e+1),s.getX(e+2),t.materialIndex):m(e,e+1,e+2,t.materialIndex)}else if(void 0!==s)for(let e=0;e<s.count;e+=3)m(s.getX(e),s.getX(e+1),s.getX(e+2));else for(let e=0;e<i.count;e+=3)m(e,e+1,e+2);return t}(e),m=n.vertices.map((e=>new p(e))),f=[];for(const e of n.faces)f.push(new d(e,m[e.a],m[e.b],m[e.c])),yield;for(let e=0,t=f.length;e<t;e++){const t=f[e];(new g).add(t)}for(const e of t)yield*this.mergeSurfacesByNormal(f,e);for(const e of f)this.surfaces.add(e.surface);let v=0;const w=[];for(const e of this.surfaces){if(e.area<=s)continue;const t=e.getCircularPaths(m);for(const e of t)this.cullPath(e,((e,t)=>{if(e.length()<r||t.length()<r)return v++,!1;const s=e.angleTo(t)*l.tm;return!(s<i||s>180-i)||(v++,!1)})),e.length>2&&w.push(e);yield}u.debug(`Culled ${v} path points`);const y=new Set,b=new Set,S=e=>`${e.x.toFixed(3)},${e.y.toFixed(3)},${e.z.toFixed(3)}`,A=e=>`${S(e.start)}:${S(e.end)}`,N=e=>`${S(e.end)}:${S(e.start)}`;for(const e of w)for(let t=0;t<e.length;t++){const s=e[t].vector,o=e[(t+1)%e.length].vector,r=new a.cF(s,o),i=A(r),n=N(r),c=S(s);b.has(i)||b.has(n)||(b.add(i),b.add(n),this.lines.push(r)),y.has(c)||(y.add(c),this.points.push(new a.F7(s)))}yield}cullPath(e,t){const s=new o.Vector3,r=new o.Vector3;let i=!0;for(;i;){i=!1;for(let o=0;o<e.length&&e.length>2;o++){const n=e[0===o?e.length-1:o-1].vector,a=e[o].vector,c=e[(o+1)%e.length].vector;s.copy(n).sub(a),r.copy(c).sub(a),t(s,r)||(e.splice(o,1),i=!0,o--)}}}*mergeSurfacesByNormal(e,t,s=5){let o=-1,r=0;for(;0!==o&&r++<s;){u.debug(`Merging surfaces by normal angle threshold: ${t}`);const s=Math.cos(l.fy*t);o=0;let r=0;for(const t of e){r++%1e3==0&&(yield);for(const e of t.vertices)for(const r of e.faces){const e=r.surface;t.surface!==e&&t.surface.normal.dot(e.normal)>=s&&(t.surface.faces.length>e.faces.length?t.surface.mergeSurfaces(e):e.mergeSurfaces(t.surface),o++)}}o&&u.debug(`Merged ${o} surfaces by normal...`)}}}var w=s(27526);const y=new i.Vy("snapcaster");var b;!function(e){e[e.UNINITIALIZED=0]="UNINITIALIZED",e[e.WORKING=1]="WORKING",e[e.READY=2]="READY"}(b||(b={}));class S{constructor(e,t){this.cameraData=e,this.engine=t,this.meshes=new Map,this.newMeshes=new Set,this.raycaster=new o.Raycaster,this.filterSnapFeature=e=>{var t,s;const{meshName:o}=e;return!o||!1!==(null===(s=null===(t=this.meshes.get(o))||void 0===t?void 0:t.filter)||void 0===s?void 0:s.call(t,e))},this.cast=(e,t,s,r)=>{let i;s&&r&&(i=(new o.Plane).setFromNormalAndCoplanarPoint(r,s)),this.raycaster.set(e.origin,e.direction);const n=this.snappingOctree.raycast(this.raycaster,t,this.filterSnapFeature)||[],c=e=>{let t=(1+e.distance)*(1+e.distanceToRay)**2;return e.object instanceof a.F7&&(t/=10),i&&i.distanceToPoint(e.point)<-.2&&(t+=10),t};return n.sort(((e,t)=>c(e)-c(t))),n},this.add=(...e)=>{for(const t of e)this.snappingOctree.add(t)},this.remove=(...e)=>{for(const t of e)this.snappingOctree.remove(t)}}dispose(){this.meshes.clear(),this.newMeshes.clear(),this._snappingOctree.clear()}get snappingOctree(){return this.preloadMeshSnapping(),this._snappingOctree}setupOctree(e){this._snappingOctree=new a.Ay(e)}async preloadMeshSnapping(){var e;!this.populateProcess&&this.newMeshes.size&&(this.populateProcess=await this.engine.commandBinder.issueCommand(new w.i("snapping",this.buildSnappingForMeshes(),6e4)),await(null===(e=this.populateProcess)||void 0===e?void 0:e.promise),this.populateProcess=null)}*buildSnappingForMeshes(){const e=new o.Vector3;for(;;){let t=null;for(const s of this.newMeshes){const o=this.meshes.get(s);if(o){const{geometry:r}=o;if(!r){y.error("No mesh to generate snapping information from!"),o.status=b.READY;continue}const i=(0,n.UX)(r).getCenter(e).distanceTo(this.cameraData.pose.position);(!t||i<t.distance)&&(t={meshName:s,geometry:r,distance:i,info:o})}}if(!t)break;this.newMeshes.delete(t.meshName),t.info.status=b.WORKING,yield*this.buildSnappingForGeometry(t.geometry,t.info),t.info.status=b.READY,t.info.geometry=null,yield}y.info(`Snapping found ${this._snappingOctree.pointCount} points and ${this._snappingOctree.lineCount} lines`)}*buildSnappingForGeometry(e,t){e.computeVertexNormals(),yield;const s=new v;yield*s.run(e),y.debug(`Mesh done, added ${s.points.length} points and ${s.lines.length} lines`);for(const e of s.points)e.meshName=t.meshName,e.meta=t.meta,this._snappingOctree.add(e);for(const e of s.lines)e.meshName=t.meshName,e.meta=t.meta,this._snappingOctree.add(e);this.engine.broadcast(new A(s))}forEachSnapFeature(e,t=!1){this.snappingOctree.traverse((s=>{t&&!this.filterSnapFeature(s)||e(s)}))}addMeshGeometry(e,t,s,o){this.meshes.has(e)||(this.meshes.set(e,{meshName:e,geometry:t,status:b.UNINITIALIZED,meta:s,filter:o}),this.newMeshes.add(e))}removeMeshGeometry(e){const t=this.meshes.get(e);t&&t.status===b.UNINITIALIZED&&(this.meshes.delete(e),this.newMeshes.delete(e))}}class A extends r.QB{constructor(e){super(),this.edgeFinder=e}}},27526:(e,t,s)=>{s.d(t,{i:()=>r});var o=s(11165);class r extends o.u{constructor(e,t,s,o=1){super(),this.payload={type:e,func:t,maxDelay:s,steps:o}}}r.id="SCHEDULE_PROCESS_COMMAND"},73427:(e,t,s)=>{s.d(t,{a:()=>h,e:()=>c});var o=s(66806),r=s(74381),i=s(86866),n=s(78498),a=s(66416);const c={[o.N.Dollhouse]:r.nE.DOLLHOUSE,[o.N.Floorplan]:r.nE.FLOORPLAN,[o.N.Panorama]:r.nE.PANORAMA,[o.N.Outdoor]:r.nE.PANORAMA,[o.N.Transition]:r.nE.MESH,[o.N.Orthographic]:r.nE.MESH,[o.N.Mesh]:r.nE.MESH,[o.N.ExteriorSplat]:r.nE.DOLLHOUSE};class h{constructor(){}serialize(e,t){if(!e.imageBlob)throw new Error("missing image to upload");const s=[];for(const[o,r]of e.metadata.floorVisibility.entries())if(1===r){const e=t.floorsData.getFloorAtIndex(o);e&&s.push(e.id)}return{label:e.name,contents:{filename:`${e.name}.jpg`,blob:e.imageBlob},snapshotLocation:{anchorId:e.metadata.scanId||void 0,visibleFloorIds:s,position:(0,n.I)(i.U$.toVisionVector(e.metadata.cameraPosition)),rotation:(0,n.p)(i.U$.toVisionCameraQuaternion(e.metadata.cameraQuaternion)),viewMode:c[e.metadata.cameraMode],zoom:e.metadata.cameraMode===o.N.Floorplan?e.metadata.orthoZoom:e.metadata.ssZoom,showExterior:e.metadata.cameraMode===o.N.ExteriorSplat},photoType:e.category===a.X.PANORAMA?r.xx.EQUIRECTANGULAR:r.xx.PHOTO2D}}}}}]);